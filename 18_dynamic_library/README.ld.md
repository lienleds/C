# `ld.so` Overview

`ld.so` is the dynamic linker/loader for ELF (Executable and Linkable Format) binaries on Unix-like systems. Its main responsibilities include:

- **Loading shared libraries** needed by a program at runtime.
- **Resolving symbol references** between the main program and its libraries.
- **Relocating symbols** to their correct memory addresses.
- **Handling dependencies and versioning** of shared libraries.

---

## How Dynamic Linking Works

When you run a dynamically linked executable, the kernel loads `ld.so` (or `ld-linux.so`) to prepare the process:

```sh
./my_program
```

`ld.so` reads the ELF headers, loads required `.so` files, and resolves symbols before transferring control to `main()`.

---

## Step-by-Step: How `ld.so` Loads a Dynamic Library

```
+---------------------+
| 1. Program Startup  |
+---------------------+
              |
              v
+-----------------------------+
| 2. Executable Header        |
|    - Lists needed .so files |
+-----------------------------+
              |
              v
+-----------------------------+
| 3. ld.so Loads Libraries    |
|    - Finds .so files        |
|    - Loads into memory      |
+-----------------------------+
              |
              v
+-----------------------------+
| 4. Symbol Resolution        |
|    - Matches function/data  |
|      names to addresses     |
+-----------------------------+
              |
              v
+-----------------------------+
| 5. Relocation               |
|    - Adjusts code/data      |
|      for actual memory      |
|      addresses              |
+-----------------------------+
              |
              v
+-----------------------------+
| 6. Program Runs             |
|    - All library functions  |
|      available              |
+-----------------------------+
```

**Explanation:**

1. **Program Startup**: The OS loads the executable and invokes `ld.so`.
2. **Executable Header**: The ELF header lists required shared libraries.
3. **ld.so Loads Libraries**: The dynamic linker finds and loads `.so` files from standard paths or those specified by `LD_LIBRARY_PATH`.
4. **Symbol Resolution**: The linker matches symbols (functions, variables) in the executable to those in the libraries.
5. **Relocation**: Adjusts code and data references to the actual memory addresses where libraries are loaded.
6. **Program Runs**: The program executes with all shared library functions available.

---

## Typical Usage Example

Suppose you have a program that depends on `libm.so` (math library) and `libc.so` (C standard library):

1. **Compile your program:**
    ```sh
    gcc -o calc calc.c -lm
    ```
2. **Run the program:**
    ```sh
    ./calc
    ```
3. **What happens:**
    - The kernel loads `ld.so`.
    - `ld.so` reads the ELF header of `calc`.
    - It finds that `calc` needs `libm.so` and `libc.so`.
    - It searches for these libraries in standard locations and those specified by `LD_LIBRARY_PATH`.
    - Loads the libraries into memory.
    - Resolves symbols like `sin()`, `printf()`, etc.
    - Transfers control to your program's `main()`.

---

## Environment Variables

| Variable         | Purpose                                                      | Example Usage                                      |
|------------------|-------------------------------------------------------------|----------------------------------------------------|
| `LD_LIBRARY_PATH`| Specifies directories to search for shared libraries         | `export LD_LIBRARY_PATH=/opt/libs:/usr/local/lib`  |
| `LD_PRELOAD`     | Forces loading of specified libraries before others          | `LD_PRELOAD=./myhook.so ./my_program`              |
| `LD_DEBUG`       | Enables debugging output from the dynamic linker             | `LD_DEBUG=libs ./my_program`                       |

---

## Related Files

| File                     | Description                                      | Example Content/Usage                              |
|--------------------------|--------------------------------------------------|----------------------------------------------------|
| `/lib/ld-linux.so.*`     | The actual dynamic linker binary                 | Used by the kernel to start dynamic executables    |
| `/etc/ld.so.conf`        | Configuration file for library search paths       | Contains directories like `/usr/local/lib`         |
| `/etc/ld.so.cache`       | Cached list of libraries for faster lookup        | Generated by running `ldconfig`                    |

---

## More Detailed Examples

### Example 1: Using `LD_LIBRARY_PATH`

Suppose you have a custom library in `/home/user/mylibs`:

```sh
export LD_LIBRARY_PATH=/home/user/mylibs
./my_program
```
- `ld.so` will search `/home/user/mylibs` for required `.so` files before standard locations.

### Example 2: Preloading a Library

You want to override a function (e.g., `malloc`) for debugging:

```sh
LD_PRELOAD=./debug_malloc.so ./my_program
```
- `ld.so` loads `debug_malloc.so` first, so its `malloc` implementation is used.

### Example 3: Debugging Library Loading

To see which libraries are loaded and in what order:

```sh
LD_DEBUG=libs ./my_program
```
- `ld.so` prints detailed information about library loading and symbol resolution.

---

## References

- [Linux man page: ld.so](https://man7.org/linux/man-pages/man8/ld.so.8.html)
- [Dynamic Linking and Loading](https://www.gnu.org/software/libc/manual/html_node/Dynamic-Linking.html)
